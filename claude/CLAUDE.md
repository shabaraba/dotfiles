# CLAUDE.md

このファイルは、Claude Code（claude.ai/code）がコードを扱う際の振る舞いと指針を定義します。

## 🔨 最重要ルール - 新しいルールの追加プロセス

ユーザーから今回限りではなく常に対応が必要だと思われる指示を受けた場合：

1. 「これを標準のルールにしますか？」と質問する
2. YESの回答を得た場合、CLAUDE.mdに追加ルールとして記載する
3. その際に、プロジェクト固有のルールなのか、開発作業全体に関わるルールなのかを判断して、プロジェクトルートのCLAUDE.mdに記載するか、~/.claude/CLAUDE.md に記載するか選択する
4. 以降は標準ルールとして常に適用する

このプロセスにより、プロジェクトのルールを継続的に改善していきます。

## 基本原則
Claude Codeは以下の原則に従って動作してください：

1. **プロジェクト全体の把握**
   - タスクに着手する前に、関連ファイルとコードベース全体の構造を把握する
   - アーキテクチャとディレクトリ構造を理解してから実装を開始する

2. **タスクの文脈理解と実装計画**
   - ユーザーの要求を正確に理解し、実装前に明確な計画を立てる
   - 必要に応じてTodoWriteツールを使用してタスクを分割・管理する
   - 実装前に既存コードの規約やパターンを確認する

3. **品質重視の実装**
   - **ファイルサイズ**: 1ファイル100行程度に収める
   - **コメント**: 不要なコメントは一切残さない
   - **モジュール化**: 関数やクラスは単一責任の原則に従う
   - **リファクタリング**: ビルドテスト後に必要に応じてリファクタを実行
   - **rootディレクトリにむやみにファイルを増やさず、必要最小限に留める**

4. **テストとビルド**
   - 実装後は必ずビルドコマンドを実行してエラーがないことを確認
   - 型チェックやリンターを実行
   - テストが存在する場合は必ず実行
   - **3回試行ルール**: ビルドやテストの失敗を3回修正してもまだ解決できない場合は、現状報告と困っている点をユーザーに伝え、アドバイスを求める

5. **mockとstubの使用禁止**
   - mockおよびstubはテストコードでのみ使用してよく、実装で使用することは禁止する

6. **コミュニケーション**
   - 定期的に進捗を報告（主要なステップごと）
   - 不明な点や設計上の判断が必要な場合は即座にユーザーに質問
   - 実装の選択肢がある場合は、理由を説明した上で提案
   - エラー解決に苦戦した場合は、遠慮なくユーザーに相談する

## ツール使用方針
- **GitHub操作**: GitHub MCPツール（`mcp_`で始まるツール）が利用可能な場合は、ghコマンドよりも優先的に使用する
- **Web検索**: MCP提供のWebツールが利用可能な場合は、通常のWebFetchツールよりも優先する
- **ローカルサーバー操作**: devtoolsMCPを使うこと

## 言語設定
- **応答言語**: 日本語で応答する
- **コミットメッセージ**: 英語でSemantic Commit Messagesを使用
  - feat: 新機能
  - fix: バグ修正
  - docs: ドキュメント更新
  - style: コード整形
  - refactor: リファクタリング
  - test: テスト追加/修正
  - chore: ビルドプロセスやツールの変更
  - **重要**: コミットはユーザーが明示的に指示した場合のみ実行すること
  - コミットメッセージに「🤖 Generated with Claude Code」等の自動追加フッターは含めないこと
- **PRタイトル**: 英語でSemantic Commit Messages形式
- **PR本文**: 日本語で詳細を記載
- **issue関連付け**: 対応するissueがある場合は`fixes #<issue番号>`を含める

## Code Style Guidelines
- **Comments**: 必要最小限のコメントのみ。コードは自己文書化を心がける

## 命名規則
- **リファクタリング時の命名**: 一時的・段階的な改善を示すプレフィックス/サフィックスは絶対に使用しない
  - ❌ 悪い例（プレフィックス）: `NewGameLogic`, `OldUserService`, `TempDatabase`, `UltimateParser`, `SuperController`, `OptimizedRenderer`
  - ❌ 悪い例（サフィックス）: `GameLogicV2`, `UserServiceFinal`, `DatabaseOptimized`, `ParserUltimate`
  - ✅ 良い例: リファクタリング完了後の最終的な名前を直接使用
  - リファクタリング時は、旧ファイルを削除してから新ファイルを正式名称で作成する
  - バージョン管理はGitで行い、ファイル名でバージョンを表現しない
- **意味のある名前**: ファイル名、クラス名、関数名は、その役割を明確に表すものにする
- **一貫性**: プロジェクト内で同じ概念には同じ命名パターンを使用する

## 実装手順の標準フロー
1. 要求内容の理解と確認
2. 関連ファイルの調査（Grep, Globツールを使用）
3. 実装計画の策定（TodoWriteで管理）
4. 実装（既存の規約に従う）
5. ビルドとテストの実行
6. 必要に応じてリファクタリング
7. 最終確認と進捗報告

## 新規実装・機能追加時の設計基準

### ファイル分割の基本方針
- **1ファイル100行程度**: 最大でも200行を超えないこと
- **単一責任の原則**: 1つのクラス/モジュールは1つの責任のみを持つ
- **高凝集性**: 関連する機能は同じモジュールに、無関係な機能は別モジュールに

### 必須の設計パターン

#### 1. Manager系クラスの分割
大規模なManagerクラスは以下のパターンで分割：
```typescript
// ❌ 悪い例：全機能を1つのManagerに
class GameManager {
  // 状態管理、ロジック処理、通信、UIすべて混在
}

// ✅ 良い例：責務ごとに分割
class GameManager {
  private stateManager: GameStateManager;
  private logicProcessor: GameLogicProcessor;
  private networkHandler: NetworkHandler;
}
```

#### 2. Factory系の実装
オブジェクト生成は個別のCreatorに委譲：
```typescript
// ❌ 悪い例：Factoryに全ロジック
class MeshFactory {
  createTypeA() { /* 50行のロジック */ }
  createTypeB() { /* 80行のロジック */ }
}

// ✅ 良い例：個別Creatorに委譲
class MeshFactory {
  static create(type: string) {
    switch(type) {
      case 'A': return TypeACreator.create();
      case 'B': return TypeBCreator.create();
    }
  }
}
```

#### 3. UI系の分割
UIコンポーネントは機能単位で分割：
```typescript
// ✅ 良い例
- UIElementManager（DOM要素管理）
- EventManager（イベント処理）
- StateUIManager（状態表示）
- ActionUIManager（操作系UI）
```

#### 4. Effect/Animation系の分割
視覚効果は生成と制御を分離：
```typescript
// ✅ 良い例
- ModelCreator（3Dモデル生成）
- AnimationController（アニメーション制御）
- EffectComposer（エフェクト合成）
```

### 実装前チェックリスト
- [ ] 新規ファイルは100行程度に収まる設計か？
- [ ] 各クラスは単一の責任を持っているか？
- [ ] 依存関係は適切に管理されているか？
- [ ] 将来の拡張性を考慮した設計か？

### 具体的な実装例

#### ネットワーク機能の実装
```typescript
// 接続管理、メッセージ処理、状態同期を分離
NetworkManager
├── ConnectionManager（接続確立・切断）
├── MessageHandler（メッセージ送受信）
├── StateSync（状態同期）
└── PingManager（接続維持）
```

#### ゲームロジックの実装
```typescript
// ゲームの各側面を独立したモジュールに
GameLogic
├── BoardManager（盤面管理）
├── MoveValidator（手の検証）
├── TurnManager（ターン制御）
└── ScoreCalculator（スコア計算）
```

### アンチパターン
- 200行を超えるファイル
- 5つ以上の責務を持つクラス
- 深い継承階層（3階層以上）
- God Object（すべてを知っているオブジェクト）

## 大規模ファイルのリファクタリング

### 方針
大規模なファイル（200行以上）を分割する際は、以下の方針に従う：

1. **モジュール分割の基準**
   - 単一責任の原則（Single Responsibility Principle）を厳守
   - 各モジュールは特定の機能や関心事に焦点を当てる
   - 凝集度を高く、結合度を低く保つ

2. **分割パターン**
   - **Manager/Service分離**: ビジネスロジックを専門マネージャーに分離
   - **Factory パターン**: オブジェクト生成ロジックの抽出
   - **Strategy パターン**: アルゴリズムや振る舞いの分離
   - **Component分離**: UI要素を論理的な単位で分割

3. **実装手順**
   - 既存ファイルの責務を明確に分析
   - 関連する機能をグループ化
   - インターフェースを定義して依存関係を明確化
   - 段階的に機能を抽出（一度に全て移動しない）
   - 各ステップでビルドとテストを実行

4. **命名規則**
   - モジュール名は役割を明確に表す（例: ConnectionManager, MoveValidator）
   - 階層構造を反映したディレクトリ構成
   - 関連モジュールは同じディレクトリにグループ化

5. **品質確保**
   - 分割後も元の機能が完全に保持されることを確認
   - 循環依存を避ける
   - 必要に応じて共通インターフェースを定義
   - ドキュメント化（特に新しいモジュール間の関係）

## Git/GitHub操作ルール

### コミット実行の条件
- **必須条件**: ユーザーが明示的に「コミットして」「commit」等の指示をした場合のみコミットを実行する
- 自動的・予防的なコミットは一切行わない
- コミット前に必ずユーザーに確認を求める場合も、明示的な指示がない限り実行しない

### コミットメッセージの形式
- Semantic Commit Messages形式を使用（feat, fix, docs, refactor等）
- メッセージは英語で記述
- **「🤖 Generated with Claude Code」等の自動追加フッターは含めないこと**
- **「Co-Authored-By: Claude」等のメタデータも含めないこと**
- シンプルで簡潔なコミットメッセージのみを記述
